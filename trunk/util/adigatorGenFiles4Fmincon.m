function funcs = adigatorGenFiles4Fmincon(setup)
% funcs = adigatorGenFiles4Fmincon(setup)
%
% ADiGator Gradient/Jacobian/Hessian File Generation Function: this
% function is used when you wish to generate derivative files for FMINCON.
% The user must specify their objective and constraint functions, and
% whether they want to generate 1st or 2nd derivatives. This function calls
% adigator on the user's functions and creates wrapper files for the
% gradient/jacobian/hessian, of the form required by FMINCON. Note: all
% auxiliary data must be both known and fixed when passed to this function.
%
%
%
% --------------------------- User Function Requirements ---------------- %
% The objective function must be of the form:
%                   obj = objective(x) OR obj = objective(x,auxdata)
% The constraint function must be of the form:
%                   con = constraints(x) OR con = constraints(x,auxdata)
% Where x corresponds to the NLP decision variable, and auxdata is a fixed
% structure/cell/array.
%
% NOTE: both the objective and constraint functions must be written in
% their own M-file.
%
% If auxdata is an input to the objective, it must also be an input to the
% constraint function, and vice verse. Note, the same auxdata structure
% should be given to both functions. Moreover, if auxdata is an input, then
% the auxdata must be given to adigatorGenFiles4Fmincon.
%
% --------------------------- Input Structure --------------------------- %
%
% setup should be a structure with the following fields:
%
% setup.order:      derivative order - 1 generates objective gradient and
%                   (if constrained) constraint Jacobian, 2 also generates
%                   Lagrangian Hessian
%
% setup.numvar:     length of the NLP variable of differentiation (i.e. x)
%
% setup.objective:  string name of the user's objective function
%
% setup.constraint: string name of the user's constraint function (if have
%                   non-linear constraints)
%
% setup.options:    (optional) options structure generated by
%                   adigatorOptions
%
% setup.auxdata:    (optional) if the objective/constraint function have an
%                   auxdata input, then the auxdata should be included here
%
%
% --------------------------- Output Structure -------------------------- %
%
% funcs.objgrad: objective gradient function handle
%
% funcs.consgrad: constraint gradient function handle
%
% funcs.hessian: hessian function handle (if order = 2)
%
% Copyright 2011-2014 Matthew J. Weinstein and Anil V. Rao
% Distributed under the GNU General Public License version 3.0
%
% see also adigator, adigatorCreateDerivInput, adigatorOptions,
% adigatorGenJacFile, adigatorGenHesFile, adigatorGenFiles4Fminunc,
% adigatorGenFiles4Fsolve

% ---------------------------- Parse Inputs ----------------------------- %

if isfield(setup,'order') && (setup.order==1 || setup.order==2)
  order = setup.order;
else
  error('must specify setup.order = 1 or setup.order = 2')
end
if isfield(setup,'numvar') && length(setup.numvar) == 1
  n = setup.numvar;
  if n < 2
    error('adigatorGenFiles4Fmincon not coded for scalar decision variable')
  end
else
  error('must specify decision vector length')
end
if isfield(setup,'objective') && ischar(setup.objective) && ...
    exist(setup.objective,'file')
  ObjFunName = setup.objective;
  ObjFun     = str2func(ObjFunName);
else
  error('must specify objective function')
end
if isfield(setup,'constraint')
  if ischar(setup.constraint) && ...
      exist(setup.constraint,'file')
    ConFunName = setup.constraint;
    ConFun     = str2func(ConFunName);
  else
    error('invalid constraint function name')
  end
  consflag = 1;
else
  consflag = 0;
end
if isfield(setup,'options')
  opts = setup.options;
  if ~isfield(opts,'overwrite')
    opts.overwrite = 1;
  end
else
  opts.overwrite = 1;
end
if isfield(setup,'auxdata')
  if nargin(ObjFun) ~= 2 || (consflag && nargin(ConFun) ~= 2)
    error('if auxdata specified, objective and constraint functions must have 2 inputs')
  end
  auxflag = 1;
  auxdata = setup.auxdata;
else
  if nargin(ObjFun) ~= 1 || (consflag && nargin(ConFun)~=1)
    error('objective and constraint function should have single input')
  end
  auxflag = 0;
end
if nargout(ObjFun)~=1
  error('objective function should have single output')
end
if consflag && nargout(ConFun)~=2
  error('constraint function should have two outputs')
end

% --------------------------- Set Up File Names ------------------------- %
GrdFileName    = [ObjFunName,'_Grd'];            % Gradient Wrapper
ObjD1FileName  = [ObjFunName,'_ADiGatorGrd'];    % Obj 1st derivs
if order == 2
  % 2nd derivs
  HesFileName   = [ObjFunName,'_Hes'];           % Hessian Wrapper
  ObjD2FileName = [ObjFunName,'_ADiGatorHes'];   % Obj 2nd derivs
  if consflag
    JacFileName   = [ConFunName,'_Grd'];           % Jacobian Wrapper
    ConD1FileName = [ConFunName,'_ADiGatorGrd'];   % Cons 1st derivs
    ConD2FileName = [ConFunName,'_ADiGatorHes'];   % Cons 2nd derivs
    AllFileNames = {GrdFileName, ObjD1FileName, HesFileName, ObjD2FileName,...
      JacFileName, ConD1FileName, ConD2FileName};
  else
    % unconstrained
    AllFileNames = {GrdFileName, ObjD1FileName, HesFileName, ObjD2FileName};
  end
elseif consflag
  % constrained 1st derivs
  JacFileName   = [ConFunName,'_Jac'];           % Jacobian Wrapper
  ConD1FileName = [ConFunName,'_ADiGatorJac'];   % Cons 1st derivs
  AllFileNames = {GrdFileName, ObjD1FileName, JacFileName, ConD1FileName};
else
  % 1st derivs
  JacFileName   = [ConFunName,'_Grd'];           % Jacobian Wrapper
  ConD1FileName = [ConFunName,'_ADiGatorGrd'];   % Cons 1st derivs
  AllFileNames = {GrdFileName, ObjD1FileName, JacFileName, ConD1FileName};
end

% ---------------------- Check/Delete All Files ------------------------- %
CallingDir = cd;
for I = 1:length(AllFileNames)
  FileNamei = AllFileNames{I};
  if exist([CallingDir,filesep,FileNamei,'.m'],'file');
    if opts.overwrite
      delete([CallingDir,filesep,FileNamei,'.m']);
      rehash
    else
      error(['The file ',CallingDir,filesep,FileNamei,'.m already exists, ',...
        'quitting transformation. To set manual overwrite of file use ',...
        '''''adigatorOptions(''OVERWRITE'',1);''''. Alternatively, delete the ',...
        'existing file and any associated .mat file.']);
    end
  end
end

% ------------------------ Differentiate Objective File ----------------- %
x = adigatorCreateDerivInput([n 1],'x');
if auxflag
  Inputs = {x, auxdata};
else
  Inputs = {x};
end
objout1 = adigator(ObjFunName,Inputs,ObjD1FileName,opts);
objout1 = objout1{1};

% ------------------------ Differentiate Constraint File ---------------- %
if consflag
  conout1 = adigator(ConFunName,Inputs,ConD1FileName,opts);
  conout1i = conout1{1}; conout1e = conout1{2};
  mi = prod(conout1i.func.size); me = prod(conout1e.func.size);
end

if order == 2
  opts.comments = 0;
  % Second deriv of objective
  x2 = struct('f',x,'dx',ones(n,1));
  Inputs2 = Inputs;  Inputs2{1} = x2;
  objout2 = adigator(ObjD1FileName,Inputs2,ObjD2FileName,opts);
  objout2 = objout2{1};
  % Second deriv of constraint
  if consflag
    conout2 = adigator(ConD1FileName,Inputs2,ConD2FileName,opts);
    conout2i = conout2{1}; conout2e = conout2{2};
  end
end

% -------------------------- Create Necessary Files --------------------- %
if auxflag
  InVarStr  = 'x,auxdata';
  dInVarStr = 'gx,auxdata';
else
  InVarStr  = 'x';
  dInVarStr = 'gx';
end
Gfid = fopen([GrdFileName,'.m'],'w+');
fprintf(Gfid,['function [f, gradf] = ',GrdFileName,'(',InVarStr,')\n']);

if order == 2
  Hfid = fopen([HesFileName,'.m'],'w+');
  fprintf(Hfid,['function Hes = ',HesFileName,'(',InVarStr,',lambda)\n']);
end
if consflag
  Jfid = fopen([JacFileName,'.m'],'w+');
  fprintf(Jfid,['function [c, ceq, gradc, gradceq] = ',JacFileName,'(',InVarStr,')\n']);
  if order == 2
    allFid = [Gfid Jfid Hfid];
  else
    allFid = [Gfid Jfid];
  end
elseif order == 2
  allFid = [Gfid Hfid];
else
  allFid = Gfid;
end

% -------------------------- Print Common File Headers ------------------ %
for fid = allFid
  % Print Function Header
  fprintf(fid,'%% \n');
  fprintf(fid,'%% Wrapper file generated by ADiGator\n');
  fprintf(fid,['%% ',char(169),'2010-2014 Matthew J. Weinstein and Anil V. Rao\n']);
  fprintf(fid,'%% ADiGator may be obtained at https://sourceforge.net/projects/adigator/ \n');
  fprintf(fid,'%% Contact: mweinstein@ufl.edu\n');
  fprintf(fid,'%% Bugs/suggestions may be reported to the sourceforge forums\n');
  fprintf(fid,'%%                    DISCLAIMER\n');
  fprintf(fid,'%% ADiGator is a general-purpose software distributed under the GNU General\n');
  fprintf(fid,'%% Public License version 3.0. While the software is distributed with the\n');
  fprintf(fid,'%% hope that it will be useful, both the software and generated code are\n');
  fprintf(fid,'%% provided ''AS IS'' with NO WARRANTIES OF ANY KIND and no merchantability\n');
  fprintf(fid,'%% or fitness for any purpose or application.\n\n');
end

% --------------------------- Print Gradient File ----------------------- %
objD1 = objout1.deriv.nzlocs;
Gnnz  = size(objD1,1);
fprintf(Gfid,'if nargout == 1\n');
fprintf(Gfid,['    f = ',ObjFunName,'(',InVarStr,');\n']);
fprintf(Gfid,'else\n');
fprintf(Gfid,'    gx.f = x;\n');
fprintf(Gfid,'    gx.dx = ones(%1.0d,1);\n',n);
fprintf(Gfid,['    obj = ',ObjD1FileName,'(',dInVarStr,');\n']);
fprintf(Gfid,'    f = obj.f;\n');
if Gnnz == n
  % Gradient is completely full
  fprintf(Gfid,'gradf = obj.dx;\n');
else
  % Gradient has some known zeros
  fprintf(Gfid,'gradf = zeros(%1.0d,1);\n',n);
  fprintf(Gfid,'gradf(obj.dx_location) = obj.dx;\n');
end
fprintf(Gfid,'end\n');

% -------------------------- Print Jacobian File ------------------------ %
if consflag
  cD1 = conout1i.deriv.nzlocs; ceqD1 = conout1e.deriv.nzlocs;
  cD1nnz = size(cD1,1);        ceqD1nnz = size(ceqD1,1);
  fprintf(Jfid,'if nargout == 2\n');
  fprintf(Jfid,['    [c, ceq] = ',ConFunName,'(',InVarStr,');\n']);
  fprintf(Jfid,'else\n');
  fprintf(Jfid,'    gx.f = x;\n');
  fprintf(Jfid,'    gx.dx = ones(%1.0d,1);\n',n);
  fprintf(Jfid,['    [con, coneq] = ',ConD1FileName,'(',dInVarStr,');\n']);
  fprintf(Jfid,'    c = con.f; ceq = coneq.f;\n');
  if mi == 0
    fprintf(Jfid,'    gradc = [];\n');
  elseif cD1nnz == mi*n
    fprintf(Jfid,'    gradc = reshape(con.dx,%1.0f,%1.0f).'';\n',mi,n);
  elseif mi == 1
    fprintf(Jfid,'    gradc = zeros(%1.0f,%1.0f);\n',n,mi);
    fprintf(Jfid,'    gradc(con.dx_location(:,1)) = con.dx;\n');
  elseif mi*n >= 250 && cD1nnz/(mi*n) < 3/4
    fprintf(Jfid,['    gradc = sparse(con.dx_location(:,2),con.dx_location(:,1),',...
      'con.dx,%1.0f,%1.0f);\n'],n,mi);
  else
    fprintf(Jfid,'    gradc = zeros(%1.0f,%1.0f);\n',n,mi);
    fprintf(Jfid,'    gradc((con.dx_location(:,1)-1)*%1.0f+con.dx_location(:,2)) = con.dx;\n',n);
  end
  if me == 0
    fprintf(Jfid,'    gradceq = [];\n');
  elseif ceqD1nnz == me*n
    fprintf(Jfid,'    gradceq = reshape(coneq.dx,%1.0f,%1.0f).'';\n',me,n);
  elseif me == 1
    fprintf(Jfid,'    gradceq = zeros(%1.0f,%1.0f);\n',n,me);
    fprintf(Jfid,'    gradceq(coneq.dx_location(:,1)) = coneq.dx;\n');
  elseif me*n >= 250 && ceqD1nnz/(me*n) < 3/4
    fprintf(Jfid,['    gradceq = sparse(coneq.dx_location(:,2),coneq.dx_location(:,1),',...
      'coneq.dx,%1.0f,%1.0f);\n'],n,me);
  else
    fprintf(Jfid,'    gradceq = zeros(%1.0f,%1.0f);\n',n,me);
    fprintf(Jfid,'    gradceq((coneq.dx_location(:,1)-1)*%1.0f+coneq.dx_location(:,2)) = coneq.dx;\n',n);
  end
  fprintf(Jfid,'end\n');
end


% --------------------------- Print Hessian File ------------------------ %
if order == 2
  % Determine if we need to use comrpession for the Constraint Hessian
  % computation(s)
  compressHes   = 0;
  compressHeseq = 0;
  if consflag && mi > 0
    cD2 = conout2i.dx.deriv.nzlocs; cD2nnz = size(cD2,1);
    if ~isempty(cD2) && mi > 1
      iCxx = cD1(cD2(:,1),1);
      jCxx = cD1(cD2(:,1),2);
      kCxx = cD2(:,2);
      jkCxx = sub2ind([n n],jCxx,kCxx);
      jkCxxc = unique(jkCxx);
      if length(jkCxxc) <= 3/4*n*n
        compressHes = 1;
      end
    end
  else
    cD2nnz = 0;
  end
  if consflag && me > 0
    ceqD2 = conout2e.dx.deriv.nzlocs; ceqD2nnz = size(ceqD2,1);
    if ~isempty(ceqD2) && me > 1
      iCeqxx = ceqD1(ceqD2(:,1),1);
      jCeqxx = ceqD1(ceqD2(:,1),2);
      kCeqxx = ceqD2(:,2);
      jkCeqxx = sub2ind([n n],jCeqxx,kCeqxx);
      jkCeqxxc = unique(jkCeqxx);
      if length(jkCeqxxc) <= 3/4*n*n
        compressHeseq = 1;
      end
    end
  else
    ceqD2nnz = 0;
  end
  
  if compressHes || compressHeseq
    fprintf(Hfid,['global ADiGator_',ConD2FileName,'\n']);
  end
  
  
  fprintf(Hfid,'gx.f = x;\n');
  fprintf(Hfid,'gx.dx = ones(%1.0d,1);\n',n);
  % Objective Hessian
  fprintf(Hfid,['obj = ',ObjD2FileName,'(',dInVarStr,');\n']);
  objHnnz = size(objout2.dx.deriv.nzlocs,1);
  if objHnnz == 0
    if n*n > 250
      fprintf(Hfid,'objHes = sparse([],[],[],%1.0d,%1.0d);\n',n,n);
    else
      fprintf(Hfid,'objHes = zeros(%1.0d);\n',n);
    end
  elseif n*n >= 250 && objHnnz/(n*n) <= 3/4
    % Project Sparse Objective Hessian
    fprintf(Hfid,['objHes = sparse(obj.dxdx_location(:,1),obj.dxdx_location(:,2),',...
      'obj.dxdx,%1.0d,%1.0d);\n'],n,n);
  elseif objHnnz > 0
    % Project Full Objective Hessian
    fprintf(Hfid,'objHes = zeros(%1.0d,%1.0d);\n',n,n);
    fprintf(Hfid,['objHes((obj.dxdx_location(:,2)-1)*%1.0f+obj.dxdx_location(:,1))',...
      ' = obj.dxdx;\n'],n);
  end
  
  % Constraint Hessian(s)
  % Project constraint 2nd derivs into m x n*n matrix to multiply through
  % by lambda (or an m x k matrix if using compression)
  if consflag
    fprintf(Hfid,['[con, coneq] = ',ConD2FileName,'(',dInVarStr,');\n']);
    if cD2nnz > 0
      if compressHes
        % Want to use compression on hessian
        indMap = zeros(1,n*n);
        indMap(jkCxxc) = 1:length(jkCxxc);
        jkCxx_comp = indMap(jkCxx);
        fprintf(Hfid,['HesData1 = ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData1;\n']);
        fprintf(Hfid,'conHesnz = lambda.ineqnonlin.''*sparse(con.dxdx_location(:,1),HesData1,con.dxdx,%1.0d,%1.0d);\n',mi,length(jkCxxc));
        % conHesnz is the non-zeros of the hessian of lambda.'*dcdc
        ijHxx = unique([jCxx,kCxx],'rows');
        fprintf(Hfid,['HesData2 = ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData2;\n']);
        fprintf(Hfid,'conHes = sparse(HesData2(:,1),HesData2(:,2),conHesnz,%1.0d,%1.0d);\n',n,n);
        setGlobalHesData(1,ConD2FileName,jkCxx_comp,ijHxx);
      elseif mi > 1
        % Multiple Inequality Constraints
        fprintf(Hfid,'conHesLocs = (con.dxdx_location(:,3)-1)*%1.0d + con.dxdx_location(:,2);\n',n);
        if mi*n*n >= 250 && cD2nnz/(mi*n*n) <= 3/4
          fprintf(Hfid,'conHesReshaped = sparse(con.dxdx_location(:,1),conHesLocs,con.dxdx,%1.0d,%1.0d);\n',mi,n*n);
          fprintf(Hfid,'conHes = reshape(sparse(lambda.ineqnonlin).''*conHesReshaped,%1.0f,%1.0f);\n',n,n);
        else
          fprintf(Hfid,'conHesReshaped = zeros(%1.0f,%1.0f);\n',mi,n*n);
          fprintf(Hfid,'conHesReshaped((conHesLocs-1)*%1.0f+con.dxdx_location(:,1)) = con.dxdx;\n',mi);
          fprintf(Hfid,'conHes = reshape(lambda.ineqnonlin.''*conHesReshaped,%1.0f,%1.0f);\n',n,n);
        end
      elseif mi == 1
        % Single Inequality Constraint
        if n*n >= 250 && cD2nnz/(n*n) <= 3/4
          fprintf(Hfid,['conHes = sparse(con.dxdx_location(:,1),con.dxdx_location(:,2),',...
            'lambda.ineqnonlin*con.dxdx,%1.0d,%1.0d);\n']);
        else
          fprintf(Hfid,'conHes = zeros(%1.0f,%1.0f);\n',n,n);
          fprintf(Hfid,['conHes((con.dxdx_location(:,2)-1)*%1.0f+con.dxdx_location(:,1))',...
            ' = lambda.ineqnonlin*con.dxdx;\n'],n);
        end
      end
    end
    if ceqD2nnz > 0
      if compressHeseq
        indMap = zeros(1,n*n);
        indMap(jkCeqxxc) = 1:length(jkCeqxxc);
        jkCeqxx_comp = indMap(jkCeqxx);
        fprintf(Hfid,['HesData3 = ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData3;\n']);
        fprintf(Hfid,'coneqHesnz = lambda.eqnonlin.''*sparse(coneq.dxdx_location(:,1),HesData3,coneq.dxdx,%1.0d,%1.0d);\n',me,length(jkCeqxxc));
        % conHesnz is the non-zeros of the hessian of lambda.'*dcdc
        ijHeqxx = unique([jCeqxx,kCeqxx],'rows');
        fprintf(Hfid,['HesData4 = ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData4;\n']);
        fprintf(Hfid,'coneqHes = sparse(HesData4(:,1),HesData4(:,2),coneqHesnz,%1.0d,%1.0d);\n',n,n);
        setGlobalHesData(0,ConD2FileName,jkCeqxx_comp,ijHeqxx);
      elseif me > 1
        % Multiple Equality Constraints
        fprintf(Hfid,'coneqHesLocs = (coneq.dxdx_location(:,3)-1)*%1.0d + coneq.dxdx_location(:,2);\n',n);
        if me*n*n >= 250 && ceqD2nnz/(me*n*n) <= 3/4
          fprintf(Hfid,'coneqHesReshaped = sparse(coneq.dxdx_location(:,1),coneqHesLocs,coneq.dxdx,%1.0d,%1.0d);\n',me,n*n);
          fprintf(Hfid,'coneqHes = reshape(sparse(lambda.eqnonlin).''*coneqHesReshaped,%1.0f,%1.0f);\n',n,n);
        else
          fprintf(Hfid,'coneqHesReshaped = zeros(%1.0f,%1.0f);\n',me,n*n);
          fprintf(Hfid,'coneqHesReshaped((coneqHesLocs-1)*%1.0f+coneq.dxdx_location(:,1)) = coneq.dxdx;\n',me);
          fprintf(Hfid,'coneqHes = reshape(lambda.eqnonlin.''*coneqHesReshaped,%1.0f,%1.0f);\n',n,n);
        end
      elseif me == 1
        % Single Equality Constraint
        if n*n >= 250 && ceqD2nnz/(n*n) <= 3/4
          fprintf(Hfid,['coneqHes = sparse(coneq.dxdx_location(:,1),coneq.dxdx_location(:,2),',...
            'lambda.eqnonlin*coneq.dxdx,%1.0d,%1.0d);\n']);
        else
          fprintf(Hfid,'coneqHes = zeros(%1.0f,%1.0f);\n',n,n);
          fprintf(Hfid,['coneqHes((coneq.dxdx_location(:,2)-1)*%1.0f+coneq.dxdx_location(:,1))',...
            ' = lambda.eqnonlin*coneq.dxdx;\n'],n);
        end
      end
    end
  else
    cD2nnz = 0; ceqD2nnz = 0;
  end
  % Create Hessian
  if objHnnz > 0
    hesStr = 'objHes+'; plusflag = 1;
  else
    hesStr = []; plusflag = 0;
  end
  if cD2nnz > 0
    hesStr = [hesStr,'conHes+']; plusflag = 1;
  end
  if ceqD2nnz > 0
    hesStr = [hesStr,'coneqHes'];
  elseif plusflag && (objHnnz>0 || cD2nnz>0)
    hesStr = hesStr(1:end-1);
  end
  if objHnnz > 0 || cD2nnz > 0 || ceqD2nnz > 0
    fprintf(Hfid,['Hes = ',hesStr,';\n']);
    % Make Hessian Symmetric
    fprintf(Hfid,'Hes = (Hes+Hes.'')/2;');
  else
    fprintf(Hfid,'Hes = sparse([],[],[],%1.0f,%1.0f);',n,n);
  end
end

% --------------------------- Close All Files --------------------------- %
for fid = allFid
  fclose(fid);
  rehash
end

% -------------------------- Create Function Calls ---------------------- %
if auxflag
  funcs.objgrd  = eval(['@(x)',GrdFileName,'(x,auxdata)']);
  if consflag
    funcs.congrd  = eval(['@(x)',JacFileName,'(x,auxdata)']);
  end
  if order == 2
    funcs.hessian = eval(['@(x,lambda)',HesFileName,'(x,auxdata,lambda)']);
  end
else
  funcs.objgrd  = str2func(GrdFileName);
  if consflag
    funcs.consgrd = str2func(JacFileName);
  end
  if order == 2
    funcs.hessian = str2func(HesFileName);
  end
end

fprintf('\n<strong>adigatorGenFiles4Fmincon</strong> successfully generated fmincon wrapper files\n\n');
end
function setGlobalHesData(flag,ConD2FileName,HesData1,HesData2) %#ok<INUSD>
eval(['global ADiGator_',ConD2FileName]);
if flag
eval(['ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData1 = HesData1;']);
eval(['ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData2 = HesData2;']);
else
eval(['ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData3 = HesData1;']);
eval(['ADiGator_',ConD2FileName,'.',ConD2FileName,'.Gator2Data.HesData4 = HesData2;']);
end
end