function funcs = adigatorGenFiles4Fminunc(setup)
% funcs = adigatorGenFiles4Fminunc(setup)
%
% ADiGator Gradient or Hessian File Generation Function: this function is
% used when you wish to generate derivative files for use in Matlab's
% optimization toolbox. The user must specify their objective function.
% This function calls adigator on the user's functions and creates a
% objective Gradient or Hessian file of the form required by matlabs
% optimization toolbox. Note: all auxiliary data must be both known and
% fixed when passed to this function.
%
% --------------------------- User Function Requirements ---------------- %
% The objective function must be of the form:
%                   obj = objective(x) OR obj = objective(x,auxdata)
% Where x corresponds to the NLP decision variable, and auxdata is a fixed
% structure/cell/array.
%
% If auxdata is an input, then the auxdata must be given to
% adigatorGenFiles4Fminunc.
%
% --------------------------- Input Structure --------------------------- %
%
% setup is should be a structure with the following fields:
%
% setup.order:      derivative order - 1 generates objective gradient, 2
%                   generates objective hessian
%
% setup.numvar:     length of the NLP variable of differentiation (i.e. x)
%
% setup.objective:  string name of the user's objective function
%
% setup.options:    (optional) options structure generated by
%                   adigatorOptions
%
% setup.auxdata:    (optional) if the objective function have an auxdata 
%                   input, then the auxdata should be included here
%
%
% --------------------------- Output Structure -------------------------- %
%
% if order = 1
% funcs.gradient: gradient function handle
% if order = 2
% funcs.hessian: hessian function handle
%
% Hessian function has output [fun, grd, hes]
%
% Copyright 2011-2014 Matthew J. Weinstein and Anil V. Rao
% Distributed under the GNU General Public License version 3.0
%
% see also adigator, adigatorCreateDerivInput, adigatorOptions,
% adigatorGenJacFile, adigatorGenHesFile, adigatorGenFiles4Fmincon,
% adigatorGenFiles4Fsolve

% ---------------------------- Parse Inputs ----------------------------- %

if isfield(setup,'numvar') && length(setup.numvar) == 1
  n = setup.numvar;
  if n < 2
    error('adigatorGenFiles4Fminunc not coded for scalar decision variable')
  end
else
  error('must specify decision vector length')
end
if isfield(setup,'objective') && ischar(setup.objective) && ...
    exist(setup.objective,'file')
  ObjFunName = setup.objective;
  ObjFun     = str2func(ObjFunName);
else
  error('must specify objective function')
end
if isfield(setup,'options')
  opts = setup.options;
  if ~isfield(opts,'overwrite')
    opts.overwrite = 1;
  end
else
  opts.overwrite = 1;
end
if isfield(setup,'auxdata')
  if nargin(ObjFun) ~= 2
    error('if auxdata specified, objective function must have 2 inputs')
  end
  auxflag = 1;
  auxdata = setup.auxdata;
else
  if nargin(ObjFun) ~= 1
    error('objective function should have single input')
  end
  auxflag = 0;
end
if nargout(ObjFun)~=1
  error('objective function should have single output')
end
if isfield(setup,'order') && (setup.order == 1 || setup.order == 2)
  order = setup.order;
else
  error('setup.order must be specified as 1 or 2')
end

% --------------------------- Set Up File Names ------------------------- %
ObjD1FileName  = [ObjFunName,'_ADiGatorGrd'];    % Obj 1st derivs
% 2nd derivs
if order
  HesFileName   = [ObjFunName,'_Hes'];             % Hessian Wrapper
  ObjD2FileName = [ObjFunName,'_ADiGatorHes'];     % Obj 2nd derivs
  AllFileNames = {ObjD1FileName, HesFileName, ObjD2FileName};
else
  HesFileName   = [ObjFunName,'_Grd'];             % Gradient Wrapper
  AllFileNames = {ObjD1FileName, HesFileName};
end


% ---------------------- Check/Delete All Files ------------------------- %
CallingDir = cd;
for I = 1:length(AllFileNames)
  FileNamei = AllFileNames{I};
  if exist([CallingDir,filesep,FileNamei,'.m'],'file');
    if opts.overwrite
      delete([CallingDir,filesep,FileNamei,'.m']);
      rehash
    else
      error(['The file ',CallingDir,filesep,FileNamei,'.m already exists, ',...
        'quitting transformation. To set manual overwrite of file use ',...
        '''''adigatorOptions(''OVERWRITE'',1);''''. Alternatively, delete the ',...
        'existing file and any associated .mat file.']);
    end
  end
end

% ------------------------ Differentiate Objective File ----------------- %
x = adigatorCreateDerivInput([n 1],'x');
if auxflag
  Inputs = {x, auxdata};
else
  Inputs = {x};
end
objout1 = adigator(ObjFunName,Inputs,ObjD1FileName,opts);
objout1 = objout1{1};

% Second deriv of objective
if order == 2
  opts.comments = 0;
  x2 = struct('f',x,'dx',ones(n,1));
  Inputs2 = Inputs;  Inputs2{1} = x2;
  objout2 = adigator(ObjD1FileName,Inputs2,ObjD2FileName,opts);
  objout2 = objout2{1};
end


% -------------------------- Create Necessary Files --------------------- %
if auxflag
  InVarStr  = 'x,auxdata';
  dInVarStr = 'gx,auxdata';
else
  InVarStr  = 'x';
  dInVarStr = 'gx';
end

Hfid = fopen([HesFileName,'.m'],'w+');
if order == 2
  fprintf(Hfid,['function [f, g, h] = ',HesFileName,'(',InVarStr,')\n']);
else
  fprintf(Hfid,['function [f, g] = ',HesFileName,'(',InVarStr,')\n']);
end

% Print Function Header
fprintf(Hfid,'%% \n');
fprintf(Hfid,'%% Wrapper file generated by ADiGator\n');
fprintf(Hfid,['%% ',char(169),'2010-2014 Matthew J. Weinstein and Anil V. Rao\n']);
fprintf(Hfid,'%% ADiGator may be obtained at https://sourceforge.net/projects/adigator/ \n');
fprintf(Hfid,'%% Contact: mweinstein@ufl.edu\n');
fprintf(Hfid,'%% Bugs/suggestions may be reported to the sourceforge forums\n');
fprintf(Hfid,'%%                    DISCLAIMER\n');
fprintf(Hfid,'%% ADiGator is a general-purpose software distributed under the GNU General\n');
fprintf(Hfid,'%% Public License version 3.0. While the software is distributed with the\n');
fprintf(Hfid,'%% hope that it will be useful, both the software and generated code are\n');
fprintf(Hfid,'%% provided ''AS IS'' with NO WARRANTIES OF ANY KIND and no merchantability\n');
fprintf(Hfid,'%% or fitness for any purpose or application.\n\n');

% ---------------------------- Function Calls  -------------------------- %
fprintf(Hfid,'if nargout == 1\n');
fprintf(Hfid,['    f = ',ObjFunName,'(',InVarStr,');\n']);
fprintf(Hfid,'elseif nargout == 2\n');
fprintf(Hfid,'    gx.f = x;\n');
fprintf(Hfid,'    gx.dx = ones(%1.0d,1);\n',n);
fprintf(Hfid,['    obj = ',ObjD1FileName,'(',dInVarStr,');\n']);
if order == 2
  fprintf(Hfid,'else\n');
  fprintf(Hfid,'    gx.f = x;\n');
  fprintf(Hfid,'    gx.dx = ones(%1.0d,1);\n',n);
  fprintf(Hfid,['    obj = ',ObjD2FileName,'(',dInVarStr,');\n']);
end
fprintf(Hfid,'end\n\n');


% Gradient
objD1 = objout1.deriv.nzlocs;
Gnnz  = size(objD1,1);
fprintf(Hfid,'if nargout > 1\n');
fprintf(Hfid,'    f = obj.f;\n');
if Gnnz == n
  % Gradient is completely full
  fprintf(Hfid,'    g = obj.dx;\n');
else
  % Gradient has some known zeros
  fprintf(Hfid,'    g = zeros(%1.0d,1);\n',n);
  fprintf(Hfid,'    g(obj.dx_location) = obj.dx;\n');
end
fprintf(Hfid,'end\n\n');

if order == 2
  fprintf(Hfid,'if nargout > 2\n');
  objD2 = objout2.dx.deriv.nzlocs;
  Hnnz  = size(objD2,1);
  if Hnnz > 0
    if n*n >= 250 && Hnnz/(n*n) <= 3/4
      % Project Sparse Objective Hessian
      fprintf(Hfid,['    h = sparse(obj.dxdx_location(:,1),obj.dxdx_location(:,2),',...
        'obj.dxdx,%1.0d,%1.0d);\n'],n,n);
    else
      % Project Full Objective Hessian
      fprintf(Hfid,'    h = zeros(%1.0d,%1.0d);\n',n,n);
      fprintf(Hfid,['    h((obj.dxdx_location(:,2)-1)*%1.0f+obj.dxdx_location(:,1))',...
        ' = obj.dxdx;\n'],n);
    end
    %fprintf(Hfid,'    h = (1/2)*(h + h.'');\n');
  else
    fprintf(Hfid,'    h = zeros(%1.0d,%1.0d);\n',n,n);
  end
  fprintf(Hfid,'end');
end

% --------------------------- Close All Files --------------------------- %
fclose(Hfid);
rehash

% -------------------------- Create Function Calls ---------------------- %

if auxflag
  func = eval(['@(x)',HesFileName,'(x,auxdata)']);
else
  func = str2func(HesFileName);
end
if order == 2
  funcs.hessian = func;
else
  funcs.gradient = func;
end
if order == 1
  fprintf('\n<strong>adigatorGenFiles4Fminunc</strong> successfully generated Grd wrapper file\n\n');
else
  fprintf('\n<strong>adigatorGenFiles4Fminunc</strong> successfully generated Hes wrapper file\n\n');  
end