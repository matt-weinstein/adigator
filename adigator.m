function [Outputs,varargout] = adigator(UserFunName,UserFunInputs,DerFileName,varargin)
% ADiGator Main Function: Called in order to initiate source transformation
% on a user's function file.
%
% ------------------------------ Usage ---------------------------------- %
% function adigator(UserFunName,UserFunInputs,DerFileName)
%                   or
% function adigator(UserFunName,UserFunInputs,DerFileName,Options)
%
% ------------------------ Input Information ---------------------------- %
% UserFunName: String name of the user function to be differentiated
%
% UserFunInputs: N x 1 cell array containing the inputs to the UserFun
%                - any inputs (or cell array elements/structure fields)
%                which have derivatives must be created using the
%                adigatorCreateDerivInput function.
%                i.e. if the first input is the variable of
%                differentiation, then the first input must be created
%                using adigatorCreateDerivInput prior to calling adigator.
%                - any other numeric inputs should be defined as they will
%                be when calling the derivative function. These will be
%                assumed to have fixed sizes and zero locations, but the
%                non-zero locations may change values. If the values are
%                always fixed, then adigatorOptions may be used to change
%                the handling of these auxiliary inputs.
%                - auxiliary inputs may also be created using the
%                adigatorCreateAuxInput function.
%
% DerFileName: String which derivative file is to be named.
%
% Options (optional): option structure generated by adigatorOptions
%                     function
%
% Copyright 2011-2014 Matthew J. Weinstein and Anil V. Rao
% Distributed under the GNU General Public License version 3.0
%
% Please report any bugs/suggestions to the forums at 
% https://sourceforge.net/projects/adigator/
%
% See also adigatorCreateDerivInput, adigatorCreateAuxInput, adigatorOptions
 
%     ADiGator is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
% 
%     ADiGator is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
% 
%     You should have received a copy of the GNU General Public License
%     along with ADiGator in adigator/COPYING.txt.  
%     If not, see <http://www.gnu.org/licenses/>.

global ADIGATOR ADIGATORFORDATA ADIGATORDATA ADIGATORVARIABLESTORAGE
tstart = tic;
version = '1.3';
%% ~~~~~~~~~~~~~~~~~~~~~~~~~~ OPTIONS SETUP ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
opts = adigatorOptions();
if nargin == 4
  optfields = fieldnames(varargin{1});
  for Fcount = 1:length(optfields)
    opts.(lower(optfields{Fcount})) = varargin{1}.(lower(optfields{Fcount}));
  end
elseif nargin ~= 3
  error('Invalid number of inputs')
end
ADIGATOR.OPTIONS.AUXDATA     = opts.auxdata;
ADIGATOR.OPTIONS.ECHO        = opts.echo;
ADIGATOR.OPTIONS.UNROLL      = opts.unroll;
ADIGATOR.OPTIONS.COMMENTS    = opts.comments;
ADIGATOR.OPTIONS.OVERWRITE   = opts.overwrite;
ADIGATOR.OPTIONS.KEYBOARD    = 0;
ADIGATOR.OPTIONS.PREALLOCATE = 0;
ADIGATOR.OPTIONS.MAXWHILEITER = opts.maxwhileiter;
ADIGATOR.OPTIONS.COMPLEX     = opts.complex;


%% ~~~~~~~~~~~~~~~~~~~~~~~~~ FILE KEEPING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
CallingDir = cd;
if exist([CallingDir,filesep,DerFileName,'.m'],'file');
  if ADIGATOR.OPTIONS.OVERWRITE
    delete([CallingDir,filesep,DerFileName,'.m']);
    rehash
  else
    error(['The file ',CallingDir,filesep,DerFileName,'.m already exists, ',...
      'quitting transformation. To set manual overwrite of file use ',...
      '''''adigatorOptions(''OVERWRITE'',1);''''. Alternatively, delete the ',...
      'existing file and any associated .mat file.']);
  end
end
if exist([CallingDir,filesep,DerFileName,'.mat'],'file')
  if ADIGATOR.OPTIONS.OVERWRITE
    delete([CallingDir,filesep,DerFileName,'.mat']);
  else
    error(['The file ',CallingDir,filesep,DerFileName,'.mat already exists, ',...
      'quitting transformation. To set manual overwrite of file use ',...
      '''''adigatorOptions(''OVERWRITE'',1);''''. Alternatively, delete the ',...
      'existing file.']);
  end
  rehash
end
[~,adigatorTempDir] = filekeeping();
%% ~~~~~~~~~~~~~~~~~~ PARSE USERFUNINPUTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
if ~ischar(UserFunName)
  error(['First input to adigator must be string name of function to be ',...
    'differentiated']);
end
if ~iscell(UserFunInputs)
  error(['Second input to adigator must be cell array of inputs to ',...
    'the function described by first input string']);
end
if ~ischar(DerFileName)
  error(['Third input to adigator must be string of desired name of ',...
    'generated derivative file']);
end
UserFun = str2func(UserFunName);
NumUserFunInputs = numel(UserFunInputs);

if nargin(UserFun) ~= NumUserFunInputs
  error('Invalid number of elements in UserFunInputs')
end
ADIGATOR.VARINFO = struct('COUNT',[],'NAMELOCS',[],'LASTOCC',[],...
  'NAMES',[],'OVERMAP',[],'SAVE',[],'RETURN',[]);
ADIGATOR.NVAROFDIFF = 0;
ADIGATOR.VAROFDIFF = struct('name',[],'size',[],'usize',[]);
TestInputs = cell(size(UserFunInputs));
for Icount = 1:NumUserFunInputs
  UserFunInputs{Icount} = ParseUserFunInputs(UserFunInputs{Icount},0);
end
TestEvalStr = cell(1,NumUserFunInputs);
for Icount = 1:NumUserFunInputs
  [UserFunInputs{Icount},TestInputs{Icount}] = ...
    ParseUserFunInputs(UserFunInputs{Icount},1);
  TestEvalStr{Icount} = sprintf('TestInputs{%1.0f},',Icount);
end
NUMvod = ADIGATOR.NVAROFDIFF;
if ~NUMvod
  error('No derivative inputs defined')
end
% Test users function file to make sure it works
TestEvalStr = cell2mat(TestEvalStr);
TestEvalStr = [UserFunName,'(',TestEvalStr(1:end-1),');'];
try
  eval(TestEvalStr);
catch UserFunErr
  warning('ADiGator:initialevalfail',...
    'Error in initial test evaluation of user file on given input info');
  rethrow(UserFunErr)
end


%% ~~~~~~~~~~~~~~~~~ GET FLOW CONTROL STRUCTURE ~~~~~~~~~~~~~~~~~~~~~~~~ %%
% See if there are any other called functions
depfunwarning = warning('query','MATLAB:DEPFUN:DeprecatedAPI');
warning('off','MATLAB:DEPFUN:DeprecatedAPI');
CalledFunctions = mydepfun(UserFunName);
warning(depfunwarning.state,'MATLAB:DEPFUN:DeprecatedAPI');
NUMcf = length(CalledFunctions);
if NUMcf > 1
  CalledFunctions = [CalledFunctions{1}; unique(CalledFunctions(2:end))];
  NUMcf = length(CalledFunctions);
end


FunctionInfo = struct('File',{},'Input',{},'Output',{},'VARINFO',...
  {},'FORDATA',{},'DERNUMBER',{},'Iteration',{},'PreviousDerivData',{});
FunCount  = 0; 
DataCount = 0;
FunFlowInfo = cell(NUMcf,1);

for CFcount = 1:NUMcf
  % --------------------Main Function or Called Function----------------- %
  FunCount = FunCount+1;
  DataCount = DataCount+1; % Need a datacount for the inputs of each function
  if length(FunctionInfo) < FunCount
    % Pre-Allocate FUNCITONINFO if needed
    FunctionInfo(FunCount*2,1).DERNUMBER = [];
  end
  
  % -----Set Global FILE field-----
  NameLoc  = strfind(CalledFunctions{CFcount},filesep);
  FILENAME = CalledFunctions{CFcount}(NameLoc(end)+1:end-2);
  FID = fopen(CalledFunctions{CFcount},'r');
  FunctionInfo(FunCount).File.Name = FILENAME;
  FunctionInfo(FunCount).File.fid  = FID;
  FunctionInfo(FunCount).File.Path = CalledFunctions{CFcount};
  
  % -----Parse the users function line of the file----
  [OutNames,InNames,~,FunEvalLoc,EvalMajorLineCount] = parsefuncIO(FID,1,0);
  % This is an actual function file so it better have a function line
  if isempty(FunEvalLoc)
    if CFcount == 1
      error(['unable to find function line in :''',FILENAME,'''']);
    else
      error(['Called file, ''',FILENAME,''', appears to be a script ',...
        'and not a function. Please either turn it into a function with',...
        ' distinct inputs/outputs or copy the code to the calling function.']); 
    end
  end
  FunctionInfo(FunCount).Input.Names         = InNames;
  FunctionInfo(FunCount).Output.Names        = OutNames;
  FunctionInfo(FunCount).Iteration.CallCount = 0;
  
  % -----Check to see if this is a previously created Derivative File---- %
  MajorLineCount = EvalMajorLineCount; fseek(FID,FunEvalLoc,-1);
  fgets(FID); MajorLineCount = MajorLineCount+1;
  BreakFlag     = 0; 
  PrevDerFlag   = 0; 
  PrevDerString = ['global ADiGator_',FILENAME]; 
  while ~BreakFlag
    FunLine = strtrim(fgets(FID));
    MajorLineCount = MajorLineCount+1;
    if strcmp(FunLine,PrevDerString)
      % This is a previously created deriv file
      PrevDerFlag = 1; 
      BreakFlag   = 1; 
    elseif ~isempty(FunLine) && ~strcmp(FunLine(1),'%')
      % Not a previously created deriv file
      BreakFlag = 1; 
    end
  end
  if PrevDerFlag
    % We don't want to read in all of the global stuff, will do this
    % seperately. But, we do want to store information about the previous
    % derivatives.
    PreviousDerivData   = load([FILENAME,'.mat']);
    ParentPrevDerivData = PreviousDerivData.(FILENAME);
    NumPrevDerivs       = length(ParentPrevDerivData.Derivative);
    FunctionInfo(FunCount).PreviousDerivData = ParentPrevDerivData;
    
    PrevDerString = sprintf('ADiGator Start Derivative Computations');
    % Last Line that we dont need is PrevDerString.
    FunLine = strtrim(fgets(FID)); MajorLineCount = MajorLineCount+1;
    while isempty(strfind(FunLine,PrevDerString))
      % Get to the last line that we dont need to read.
      FunEvalLoc     = ftell(FID); 
      FunLine        = strtrim(fgets(FID));
      MajorLineCount = MajorLineCount+1;
    end
    EvalMajorLineCount = MajorLineCount;
    FunctionInfo(FunCount).DERNUMBER         = NumPrevDerivs+1;
  else
    FunctionInfo(FunCount).PreviousDerivData = [];
    FunctionInfo(FunCount).DERNUMBER         = 1;
  end
  
  % -----Get FlowInfo-----
  FlowInfo = struct('Type','main',...
    'StartLocation',[EvalMajorLineCount,1,1,FunEvalLoc],...
    'EndLocation',[],'Children',[]);
  FlowInfo.Children = struct('Type',cell(0),'StartLocation',cell(0),...
    'EndLocation',cell(0),'Children',cell(0));

  InnerCount = 0; MinorLineCount = 0;
  MajorLineCount = EvalMajorLineCount-1;
  FileLoc = FunEvalLoc;
  EndFlag = 0;
  while EndFlag == 0
    [MajorLineCount,MinorLineCount,TempFlowInfo,FileLoc,InnerCount,DataCount,OffSet] =...
      flowread(FID,MajorLineCount,MinorLineCount,FlowInfo.Children,FileLoc,InnerCount,DataCount);
    if isempty(TempFlowInfo)
      EndFlag = 1;
    else
      FlowInfo.Children = TempFlowInfo(1:InnerCount);
      MajorLineCount = MajorLineCount - OffSet;
    end
  end
  DataCount = DataCount+1; % Need another DataCount for the End of the File
  FlowInfo.EndLocation  = [MajorLineCount,MinorLineCount,DataCount,FileLoc];
  FunFlowInfo{FunCount} = FlowInfo;
  
  % -----------------------Sub-Functions--------------------------------- %
  SubFlag = 1;
  while SubFlag
    % Parse the users sub-function line (if exists)
    [OutNames,InNames,FunStr,FunEvalLoc,EvalMajorLineCount] = parsefuncIO(FID,MajorLineCount,FileLoc);
    if ~isempty(FunEvalLoc)
      % Found a sub-function
      if strfind(FunStr,'ADiGator_LoadData()')
        break
      end
      FunCount  = FunCount+1;
      DataCount = DataCount+1;
      NameLoc1  = strfind(FunStr,'=');
      NameLoc2  = strfind(FunStr,'(');
      FILENAME  = strtrim(FunStr(NameLoc1(1)+1:NameLoc2(1)-1));

      
      FunctionInfo(FunCount).File.Name           = FILENAME;
      FunctionInfo(FunCount).File.fid            = FID;
      FunctionInfo(FunCount).File.Path           = CalledFunctions{CFcount};
      FunctionInfo(FunCount).Input.Names         = InNames;
      FunctionInfo(FunCount).Output.Names        = OutNames;
      FunctionInfo(FunCount).Iteration.CallCount = 0;
      
      if PrevDerFlag
        % Parent of this sub-function is a previously created derivative
        % file, so this has to be too.
        ChildDerivData = PreviousDerivData.(FILENAME);
        NumPrevDerivs  = length(ChildDerivData.Derivative);
        FunctionInfo(FunCount).PreviousDerivData = ChildDerivData;

        PrevDerString = sprintf('ADiGator Start Derivative Computations');
        % Last Line that we dont need is PrevDerString.
        fseek(FID,FunEvalLoc,-1); FunLine = strtrim(fgets(FID));
        EvalMajorLineCount = EvalMajorLineCount+1;
        while isempty(strfind(FunLine,PrevDerString));
          FunEvalLoc = ftell(FID); FunLine = strtrim(fgets(FID));
          EvalMajorLineCount = EvalMajorLineCount+1;
        end
        FunctionInfo(FunCount).DERNUMBER = NumPrevDerivs+1;
      else
        FunctionInfo(FunCount).DERNUMBER = 1;
        FunctionInfo(FunCount).PreviousDerivData = [];
      end
      
      FlowInfo = struct('Type','main',...
        'StartLocation',[EvalMajorLineCount,1,1,FunEvalLoc],...
        'EndLocation',[],'Children',[]);
      FlowInfo.Children = struct('Type',cell(0),'StartLocation',cell(0),...
        'EndLocation',cell(0),'Children',cell(0));
      InnerCount = 0; MinorLineCount = 0;
      MajorLineCount = EvalMajorLineCount-1;
      FileLoc = FunEvalLoc;
      EndFlag = 0;
      while EndFlag == 0
        [MajorLineCount,MinorLineCount,TempFlowInfo,FileLoc,InnerCount,DataCount,OffSet] =...
          flowread(FID,MajorLineCount,MinorLineCount,FlowInfo.Children,FileLoc,InnerCount,DataCount);
        if isempty(TempFlowInfo)
          EndFlag = 1;
        else
          FlowInfo.Children = TempFlowInfo(1:InnerCount);
          MajorLineCount = MajorLineCount - OffSet;
        end
      end
      DataCount = DataCount+1; % Need another DataCount for the End of the File
      FlowInfo.EndLocation  = [MajorLineCount,MinorLineCount,DataCount,FileLoc];
      FunFlowInfo{FunCount} = FlowInfo;
    else
      % There are no more subfunctions
      SubFlag = 0;
    end
  end
end
FunctionInfo = FunctionInfo(1:FunCount);
% -----Check and make sure that no two functions are named the same thing
% (either called functions or sub functions)-----
FunStrChecks = cell(FunCount,1);
for Fcount = 1:FunCount
  CheckName = FunctionInfo(Fcount).File.Name;
  for F2count = Fcount+1:FunCount
    if strcmp(CheckName,FunctionInfo(F2count).File.Name)
      error('Currently cannot have two functions with the same names (including sub functions)')
    end
  end
  FunStrChecks{Fcount} = ['\W',CheckName,'('];
end


%% ~~~~~~~~~~~~~~~ DETERMINE WHAT NEEDS DERIV TAKEN ~~~~~~~~~~~~~~~~~~~~ %%
ADIGATOR.DERIVCHECKS = struct('STRINGS',cell(FunCount,1),'NUM',cell(FunCount,1));
for Fcount = 1:FunCount
  [DerivCheckCell, LastDerivNum,DerNumber] =...
    getderivchecks(FunctionInfo(Fcount).PreviousDerivData);
  FunctionInfo(Fcount).DERNUMBER      = DerNumber;
  ADIGATOR.DERIVCHECKS(Fcount).STRINGS = DerivCheckCell;
  ADIGATOR.DERIVCHECKS(Fcount).NUM     = LastDerivNum;
end

%% ~~~~~~~~~~~~~~ CREATE INTERMEDIATE PROGRAM FILES ~~~~~~~~~~~~~~~~~~~~ %%
for Fcount = 1:FunCount
  ADIGATOR.SVACOUNT = 0; ADIGATOR.SVRCOUNT = 0;
  DerNumber  = FunctionInfo(Fcount).DERNUMBER;
  TempFunStr = sprintf('adigatortempfunc%1.0d',Fcount);
  Tfid = fopen([adigatorTempDir,filesep,TempFunStr,'.m'],'w+');
  % Function Header
  fprintf(Tfid,['function [adigatorFunInfo, adigatorOutputs] = ',...
    TempFunStr,'(adigatorFunInfo,adigatorInputs)\n']);
  % Call to adigatorFunctionInitialize
  if DerNumber == 1
    fprintf(Tfid,['[flag, adigatorFunInfo, adigatorInputs] = ',...
      'adigatorFunctionInitialize(%1.0d,adigatorFunInfo,adigatorInputs);\n'],Fcount);
  else
    fprintf(Tfid,['[flag, adigatorFunInfo, adigatorInputs, adigatorDerivData] = ',...
      'adigatorFunctionInitialize(%1.0d,adigatorFunInfo,adigatorInputs);\n'],Fcount);
  end
  fprintf(Tfid,'if flag; adigatorOutputs = adigatorInputs; return; end;\n');
  % Print out Previous Derivative Data References
  for Dcount = 1:DerNumber-1
    %fprintf(Tfid,['Gator%1.0dIndices = ',...
    %  'adigatorDerivData.Gator%1.0dIndices;\n'],Dcount,Dcount);
    fprintf(Tfid,['Gator%1.0dData = ',...
      'adigatorDerivData.Gator%1.0dData;\n'],Dcount,Dcount);
  end
  NumOutputs = length(FunctionInfo(Fcount).Output.Names);
  NumInputs  = length(FunctionInfo(Fcount).Input.Names);
  % Assign adigatorInputs to proper names
  for Icount = 1:NumInputs
    fprintf(Tfid,[FunctionInfo(Fcount).Input.Names{Icount},...
      ' = adigatorInputs{%1.0d};\n'],Icount);
  end
  fprintf(Tfid,'nargin = %1.0d; nargout = %1.0d;',NumInputs,NumOutputs);
  if Fcount > 1 && ~ADIGATOR.OPTIONS.UNROLL
    ForCount = 1;
  else
    ForCount = 0;
  end
  % Print the body of the file with adigatorPrintTempFiles
  [ForCount,IfCount] = adigatorPrintTempFiles(FunctionInfo(Fcount).File.fid,Tfid,...
    FunFlowInfo{Fcount},DerNumber,ForCount,FunStrChecks);
  % Assign outputs to adigatorOutputs
  
  OutputStr = cell(1,NumOutputs);
  for Ocount = 1:NumOutputs
    OutputStr{Ocount} = [FunctionInfo(Fcount).Output.Names{Ocount},';'];
  end
  OutputStr = cell2mat(OutputStr);
  fprintf(Tfid,['adigatorOutputs = {',OutputStr(1:end-1),'};\n']);
  % Call to adigatorFunctionEnd
  fprintf(Tfid,['[adigatorFunInfo, adigatorOutputs] = ',...
    'adigatorFunctionEnd(%1.0f,adigatorFunInfo,adigatorOutputs);\n'],Fcount);


  FunctionInfo(Fcount).FORDATA = struct('START',cell(0,1),'END',[],...
    'COUNTNAME',[],'PREVOVERMAP',[],'COUNT',[],'FOR',[],'SUBSREF',...
    [],'SUBSASGN',[],'SPARSE',[],'NONZEROS',[],'HORZCAT',[],'VERTCAT',...
    [],'TRANSPOSE',[],'REPMAT',[],'RESHAPE',[],'SIZE',[],'OTHER',[],...
    'STRUCTREF',[],'STRUCTASGN',[],'CONTRESTORE',[],'PARENTLOC',[],...
    'WHILEFLAG',[]);
  if ForCount
    FunctionInfo(Fcount).FORDATA(ForCount,1).COUNT = [];
  end
  FunctionInfo(Fcount).IFDATA  = struct('ELSEFLAG',cell(0,1),'BROS',[]);
  if IfCount
    FunctionInfo(Fcount).IFDATA(IfCount,1).BROS(1).START = [];
  end
  FunctionInfo(Fcount).STRUCASGN = struct('dummy',...
    cell(1,ADIGATOR.SVACOUNT),'inds',[]);
  fclose(Tfid);
end
rehash

%% ~~~~~~~~~~~~~~~~~~~~~~ ECHO PRE-PRINTING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
if ADIGATOR.OPTIONS.ECHO
  if NUMvod > 1
    disp(['Transforming User Function: ''',UserFunName,'''']);
    DispStr = cell(1,NUMvod);
    DispStr{1} = sprintf(['    Taking Derivatives wrt: ''',...
      ADIGATOR.VAROFDIFF(1).name,', ']);
    for Vcount = 2:NUMvod-1
      DispStr{Vcount} = sprintf([' ''',...
        ADIGATOR.VAROFDIFF(Vcount).name,', ']);
    end
    DispStr{NUMvod} = sprintf(['''',...
      ADIGATOR.VAROFDIFF(NUMvod).name,'...']);
    disp(cell2mat(DispStr));
  else
    fprintf('Call to <strong>adigator</strong>:\n');
    fprintf(['Transforming user function: ''',UserFunName,'''\n',...
      '    taking derivatives wrt:  ''',ADIGATOR.VAROFDIFF(1).name,...
      '''...\n']);
  end
end

%% ~~~~~~~~~~~~~~~~~~~~ SET GLOBAL ENVIRONMENT ~~~~~~~~~~~~~~~~~~~~~~~~~ %%
ADIGATOR.DERNUMBER     = 0;
ADIGATOR.VARINFO.COUNT = 0;
ADIGATOR.FORINFO.FLAG  = 0;
ADIGATOR.FILE.FUNID    = 0;
ADIGATOR.FILE.CALLFLAG = 0;
ADIGATOR.FILE.PARENTID = [];
ADIGATORFORDATA        = [];
ADIGATOR.SUBSINDEXFLAG = 0;
ADIGATOR.CELLEVALFLAG  = 0;


ADIGATORDATA.FILENAME   = DerFileName;
Dfid = fopen([CallingDir,filesep,DerFileName,'.m'],'w+');
ADIGATOR.PRINT.FILENAME = DerFileName;
ADIGATOR.PRINT.FID      = Dfid;
ADIGATOR.PRINT.FLAG     = 0;
ADIGATOR.PRINT.INDENT   = [];
% Print the derivative function header
fprintf(Dfid,['%% This code was generated using ADiGator version ',version,'\n']);
fprintf(Dfid,['%% ',char(169),'2010-2014 Matthew J. Weinstein and Anil V. Rao\n']);
fprintf(Dfid,'%% ADiGator may be obtained at https://sourceforge.net/projects/adigator/ \n');
fprintf(Dfid,'%% Contact: mweinstein@ufl.edu\n');
fprintf(Dfid,'%% Bugs/suggestions may be reported to the sourceforge forums\n');
fprintf(Dfid,'%%                    DISCLAIMER\n');
fprintf(Dfid,'%% ADiGator is a general-purpose software distributed under the GNU General\n');
fprintf(Dfid,'%% Public License version 3.0. While the software is distributed with the\n');
fprintf(Dfid,'%% hope that it will be useful, both the software and generated code are\n');
fprintf(Dfid,'%% provided ''AS IS'' with NO WARRANTIES OF ANY KIND and no merchantability\n');
fprintf(Dfid,'%% or fitness for any purpose or application.\n\n');
%% ~~~~~~~~~ PREALLOCATION RUN (if Struc/Cell Assignments) ~~~~~~~~~~~~~ %%
if ADIGATOR.OPTIONS.PREALLOCATE
  ADIGATOR.RUNFLAG = 0;
  FunctionInfo = adigatortempfunc1(FunctionInfo,TestInputs);
  ADIGATOR.OPTIONS.PREALLOCATE = 0;
end
%% ~~~~~~~~~~~~~~~~~~~ PERFORM EMPTY TRACE RUN ~~~~~~~~~~~~~~~~~~~~~~~~~ %%
ADIGATOR.RUNFLAG        = 0;
FunctionInfo = adigatortempfunc1(FunctionInfo,UserFunInputs);
RollFlag  = 0;
for Fcount = 1:FunCount
  if FunctionInfo(Fcount).Iteration.CallCount > 0
    FunctionInfo(Fcount).Iteration.CallCount = 0;
    FORDATA   = FunctionInfo(Fcount).FORDATA;
    IFDATA    = FunctionInfo(Fcount).IFDATA;
    VARINFO   = FunctionInfo(Fcount).VARINFO;
    BREAKLOCS = FunctionInfo(Fcount).BREAKLOCS;
    CONTLOCS  = FunctionInfo(Fcount).CONTLOCS;
    ERRORLOCS = FunctionInfo(Fcount).ERRORLOCS;
    FunAsLoopFlag = FunctionInfo(Fcount).FunAsLoopFlag;
    [FORDATA,IFDATA,VARINFO,VARSTORAGE] = adigatorAssignOvermapScheme(Fcount,...
      FunAsLoopFlag,FORDATA,IFDATA,VARINFO,BREAKLOCS,CONTLOCS,ERRORLOCS,ADIGATOR.OPTIONS.UNROLL);
    
    FunctionInfo(Fcount).FORDATA    = FORDATA;
    FunctionInfo(Fcount).IFDATA     = IFDATA;
    FunctionInfo(Fcount).VARINFO    = VARINFO;
    FunctionInfo(Fcount).VARSTORAGE = VARSTORAGE;
    if ~isempty(VARINFO.OVERMAP.FOR) || ~isempty(VARINFO.OVERMAP.IF)
      RollFlag = 1;
    end
  end
end
UserUnrollFlag = ADIGATOR.OPTIONS.UNROLL;
if ~RollFlag
  ADIGATOR.OPTIONS.UNROLL = 1;
end
%% ~~~~~~~~~~~~~~~~~~ OVERMAPPING RUN (IF NEEDED) ~~~~~~~~~~~~~~~~~~~~~~ %%
if ~ADIGATOR.OPTIONS.UNROLL
  ADIGATOR.RUNFLAG       = 1;
  ADIGATOR.EMPTYFLAG     = 0;
  ADIGATOR.FILE.FUNID    = 0;
  ADIGATOR.FILE.PARENTID = [];
  FunctionInfo = adigatortempfunc1(FunctionInfo,UserFunInputs);
  % ------------------- Anaylyze any FOR Data --------------------------- %
  dummyVar = cada([],[],[]);
  ADIGATOR.PRINT.FLAG  = 1;
  IterationDependency = zeros(FunCount,1);
  for Fcount = 1:FunCount
    ADIGATORFORDATA             = FunctionInfo(Fcount).FORDATA;
    ADIGATORVARIABLESTORAGE     = FunctionInfo(Fcount).VARSTORAGE;
    ADIGATORDATA.INDEXCOUNT     = 0;
    ADIGATORDATA.INDEXCOUNT     = 0;   ADIGATORDATA.DATACOUNT  = 0;
    %ADIGATORDATA.INDICES        = [];  
    %ADIGATORDATA.INDICES.Index1 = [];  
    ADIGATORDATA.DATA           = []; 
    ADIGATORDATA.DATA.Data1     = [];
    ADIGATORDATA.DATA.Index1    = [];
    ADIGATOR.DERNUMBER          = FunctionInfo(Fcount).DERNUMBER;
    ADIGATOR.VARINFO            = FunctionInfo(Fcount).VARINFO;
    ADIGATOR.FUNDEP             = 0;
    for ForCount = 1:length(ADIGATORFORDATA)
      if ~ADIGATORFORDATA(ForCount).PARENTLOC
        adigatorAnalyzeForData(ForCount,dummyVar);
      end
    end
    if FunctionInfo(Fcount).FunAsLoopFlag && ADIGATOR.FUNDEP
      IterationDependency(Fcount) = 1;
    end
    FunctionInfo(Fcount).FORDATA = ADIGATORFORDATA;
    FunctionInfo(Fcount).DATA    = ADIGATORDATA;
  end
  % Second Pass - For Functions which think they are Independent
  %     - Check and see if they call any other functions which are dependent.
  %     - If they do, then they have to be Dependent.
  IterationDependency2 = zeros(FunCount,1);
  while ~isequal(IterationDependency,IterationDependency2)
    % Need to run this in a while loop until nothing changes - if a function
    % is indep. and calls another which is indep. which calls another which
    % is dep. then the first needs to be made dependent too.
    IterationDependency2 = IterationDependency;
    for Fcount = 2:FunCount
      if IterationDependency(Fcount)
        % This Function is Dependent - Make All Functions which call this be
        % dependent as well.
        CallerFuncs = FunctionInfo(Fcount).Iteration.CallerID(1,:);
        IterationDependency(CallerFuncs) = 1;
      end
    end
  end
  % Third Pass - Assign Dependencies
  for Fcount = 1:FunCount
    if IterationDependency(Fcount) &&...
        FunctionInfo(Fcount).Iteration.IterCount > 1
      if FunctionInfo(Fcount).DERNUMBER > 1
        % Second or Higher Derivative - Can check and see if the previous run
        % was dependent and we can use the same funcount or not.
        LastCountStr = FunctionInfo(Fcount).Input.Names{end};
        if length(LastCountStr) > 12 && strcmp(LastCountStr(1:4),'cada')...
            && strcmp(LastCountStr(end-7:end),'funcount')
          % Already have a funcount coming in to the function
          InCounts = FunctionInfo(Fcount).Input.StrucVars(end,:);
          SameFlag = 1;
          for Icount = 1:length(InCounts)
            if numel(InCounts{Icount}.func.value) ~= 1 ||...
                InCounts{Icount}.func.value ~= Icount
              SameFlag = 0; break
            end
          end
          if SameFlag
            FunctionInfo(Fcount).Iteration.DepFlag = [1 0];
          else
            FunctionInfo(Fcount).Iteration.DepFlag = [1 1];
          end
        else
          FunctionInfo(Fcount).Iteration.DepFlag = 1;
        end
      else
        FunctionInfo(Fcount).Iteration.DepFlag = 1;
      end
    else
      FunctionInfo(Fcount).Iteration.DepFlag = 0;
    end
  end
else
  for Fcount = 1:FunCount
    ADIGATORDATA.INDEXCOUNT     = 0;   ADIGATORDATA.DATACOUNT  = 0;
    ADIGATORDATA.DATA       = [];
    ADIGATORDATA.DATA.Index1 = [];  ADIGATORDATA.DATA.Data1 = [];
    FunctionInfo(Fcount).DATA    = ADIGATORDATA;
    FunctionInfo(Fcount).Iteration.DepFlag = 0;
  end
end

%% ~~~~~~~~~~~~~~~~~~~~~~~~~~ PRINTING RUN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
if ADIGATOR.OPTIONS.ECHO
  disp(['Printing derivatives to file ''',DerFileName,'''']);
end
ADIGATOR.RUNFLAG         = 2;
ADIGATOR.FILE.FUNID      = 0;
ADIGATOR.FILE.PARENTID   = [];
ADIGATOR.PRINT.FLAG      = 1;

% Call Main Function
FunctionInfo(1).Iteration.CallCount = 0;
[FunctionInfo, Outputs] = adigatortempfunc1(FunctionInfo,UserFunInputs);

if ~ADIGATOR.OPTIONS.UNROLL
  FunctionInfo(1).Iteration.CallCount = 1;
  % Call Sub-Functions
  for Fcount = 2:FunCount
    % Need to get Overmapped Inputs
    FunctionInfo(Fcount).Iteration.CallCount = 0;
    if FunctionInfo(Fcount).FunAsLoopFlag
      OverInputs = cell(size(FunctionInfo(Fcount).Input.StrucNames));
      for Ocount = 1:length(OverInputs)
        OverLoc = FunctionInfo(Fcount).VARINFO.OVERMAP.FOR(Ocount,1);
        OverInputs{Ocount} = FunctionInfo(Fcount).VARSTORAGE.OVERMAP{OverLoc};
      end
      OverInputs = cadaGetOverVars(Fcount,FunctionInfo,OverInputs);
    else
      OverInputs = FunctionInfo(Fcount).Input.StrucVars;
      OverInputs = cadaGetOverVars(Fcount,FunctionInfo,OverInputs);
    end
    FuncStr  = sprintf('adigatortempfunc%1.0d',Fcount);
    FuncCall = str2func(FuncStr);
    FunctionInfo = feval(FuncCall,FunctionInfo,OverInputs);
    FunctionInfo(Fcount).Iteration.CallCount = 1;
  end
end
if ADIGATOR.OPTIONS.UNROLL
  for Fcount = 2:FunCount
    tempfilename = sprintf('adigatortempsubfunc%1.0f.m',Fcount);
    if exist(tempfilename,'file')
      tfid = FunctionInfo(Fcount).TempFID;
      frewind(tfid);
      subfuncc = fread(tfid,1024*1024);
      while ~isempty(subfuncc)
        fwrite(Dfid,subfuncc,'uchar');
        subfuncc = fread(tfid,1024*1024);
      end
      fclose(tfid);
      delete(tempfilename);
    end
  end
end
fprintf(Dfid,'\n\nfunction ADiGator_LoadData()\n');
fprintf(Dfid,['global ADiGator_',ADIGATOR.PRINT.FILENAME,'\n']);
fprintf(Dfid,['ADiGator_',ADIGATOR.PRINT.FILENAME,' = load(''',...
  ADIGATOR.PRINT.FILENAME,'.mat'');\n']);
fprintf(Dfid,'return\nend');

eval(['global ADiGator_',ADIGATOR.PRINT.FILENAME]);
eval(['ADiGator_',ADIGATOR.PRINT.FILENAME,' = load(''',...
  ADIGATOR.PRINT.FILENAME,'.mat'');']);

fclose('all');
if ADIGATOR.OPTIONS.ECHO
  display(['Successfully transformed user function ''',UserFunName,...
    ''' to derivative function ''',DerFileName,'''']);
  gentime = toc(tstart);
  display(['Total file generation time: ',num2str(gentime)]);
end
ADIGATOR.OPTIONS.UNROLL = UserUnrollFlag;
if nargout == 2
  varargout{1} = FunctionInfo(1);
end
rmpath(adigatorTempDir);
[sflag,msg] = rmdir(adigatorTempDir,'s');
if ~sflag
  warning('Could not remove old temp directory -- message produced: %s',msg);
end
return
end

%% ~~~~~~~~~~~~~~~~~~~~~~~~~~ FILEKEEPING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
function [SoftwareLocation,adigatorTempDir] = filekeeping()
SoftwareLocation = which('adigator');
SoftwareLocation = SoftwareLocation(1:end-11);
% Delete any previously created dummy files
adigatorTempDir = [SoftwareLocation,filesep,'adigatorTempDir',filesep];
if exist(adigatorTempDir,'dir')
  P = path;
  if ~isempty(strfind(P,[adigatorTempDir(1:end-1),':']))
    rmpath(adigatorTempDir);
  end
  [sflag,msg] = rmdir(adigatorTempDir,'s');
  if ~sflag
    warning('Could not remove old temp directory -- message produced: %s',msg);
  end
end
[sflag,msg] = mkdir(adigatorTempDir);
if ~sflag
  error('Could not create temp directory -- message produced: %s',msg);
end
addpath(adigatorTempDir);
rehash
return
end

%% ~~~~~~~~~~~~~~~~~~~~~~~~~~ INPUT PARSE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
function [x, xt] = ParseUserFunInputs(x,changeflag)
global ADIGATOR
nvod = ADIGATOR.NVAROFDIFF;
xt   = x;
if isa(x,'cada')
  if ~changeflag
    for Vcount = 1:length(x.deriv)
      vodname = x.deriv(Vcount).vodname;
      vodsize = x.deriv(Vcount).vodsize;
      matchflag = 0;
      for V2count = 1:ADIGATOR.NVAROFDIFF
        if strcmp(ADIGATOR.VAROFDIFF(V2count).name,vodname)
          matchflag = 1;
          if ~isequal(ADIGATOR.VAROFDIFF(V2count).size,vodsize)
            error(['multiple inputs have derivatives wrt ''',vodname,...
              ''', where the size of ''',vodname,...
              ''' has been defined differently for two or more of the inputs'])
          end
        end
      end
      if ~matchflag
        nvod = nvod+1;
        ADIGATOR.NVAROFDIFF = nvod;
        ADIGATOR.VAROFDIFF(nvod).name = vodname;
        ADIGATOR.VAROFDIFF(nvod).size = vodsize;
        if any(isinf(vodsize))
          ADIGATOR.VAROFDIFF(nvod).usize = vodsize(~isinf(vodsize));
        else
          ADIGATOR.VAROFDIFF(nvod).usize = prod(vodsize);
        end
      end
    end
  else
    deriv2 = struct('name',cell(nvod,1),'nzlocs',cell(nvod,1));
    for Vcount = 1:length(x.deriv)
      vodname = x.deriv(Vcount).vodname;
      nzlocs  = x.deriv(Vcount).nzlocs;
      for V2count = 1:nvod
        if strcmp(vodname,ADIGATOR.VAROFDIFF(V2count).name)
          deriv2(V2count).nzlocs = nzlocs;
          break
        end
      end
    end
    x  = cada(1,x.func,deriv2);
    xsize = x.func.size;
    xsize(isinf(xsize)) = 10;
    xt = rand(xsize);
  end
elseif iscell(x)
  cellsize = numel(x);
  for Ccount = 1:cellsize
    [x{Ccount}, xt{Ccount}] = ParseUserFunInputs(x{Ccount},changeflag);
  end
elseif isstruct(x)
  strucnames = fieldnames(x);
  strucsize  = numel(x);
  for Scount = 1:strucsize
    for S2count = 1:length(strucnames)
      [x(Scount).(strucnames{S2count}), xt(Scount).(strucnames{S2count})]...
        = ParseUserFunInputs(x(Scount).(strucnames{S2count}),changeflag);
    end
  end
end

end

%% ~~~~~~~~~~~~~~~~~~~~~~ LOOK FOR CALLED FUNCTIONS ~~~~~~~~~~~~~~~~~~~~ %%
function CalledFunctions = mydepfun(UserFunName)

%--------------------------------------------------------------------------%
% BEGIN: Code Added by Anil V. Rao.  15 October 2015.                      %
%--------------------------------------------------------------------------%
% Mathworks has removed the function DEPFUN from R2015b (version 8.6)      %
% and has replaced it with MATLAB.CODETOOLS.REQUIREDFILESANDPRODUCTS.      %
% As a result, it is necessary to check the version of MATLAB being used   %
% to ensure that function dependencies are identified correctly.           %
% The block of code below checks the MATLAB version and calls the function %
% DEPFUN if the version is R2015a or earlier, and calls the function       %
% MATLAB.CODETOOLS.REQUIREDFILESANDPRODUCTS for R2015b and beyond.         
%
%mjw - used verLassThan check for version number, also, new function
%already has recursion built in so the recursive nature is not necessary.
%   - keeping the old code due to fact that new code is extremely slow.
%
% mjw - changed this to look at all cada methods and throw out any
% functions that have been overloaded.
%--------------------------------------------------------------------------%

cadaMethods = methods(cada(0,struct(),struct()));
if verLessThan('matlab','8.6');
  % Original Code in ADIGATOR.M prior to introduction of new code
  % consists of only the ONE line below.
  CalledFunctions = depfun(UserFunName,'-quiet','-toponly');
  
  CFtotal = length(CalledFunctions);
  OtherFuncs = cell(CFtotal,1);
  for CFcount = 2:CFtotal
    fileloc = strfind(CalledFunctions{CFcount},filesep);
    if isempty(fileloc); fileloc=0; end;
    filename = CalledFunctions{CFcount}(fileloc(end)+1:end-2);
    if any(strcmp(filename,cadaMethods))
      CalledFunctions{CFcount} = [];
      CFtotal = CFtotal-1;
    else
      OtherFuncs{CFcount} = mydepfun(CalledFunctions{CFcount});
      CFtotal = CFtotal+length(OtherFuncs{CFcount});
    end
  end
  
  CalledFunctions = CalledFunctions(~cellfun('isempty',CalledFunctions));
  if length(CalledFunctions) < CFtotal
    CFcount2 = length(CalledFunctions);
    CalledFunctions{CFtotal,1} = [];
    for CFcount = 1:length(OtherFuncs)
      OtherFun = OtherFuncs{CFcount};
      OFlength = length(OtherFun);
      CalledFunctions(CFcount2+1:CFcount2+OFlength) = OtherFun;
      CFcount2 = CFcount2+OFlength;
    end
  end
else
  %----------------------------------------------------------------------------%
  % The block of code below works as follows.  First, the MATLAB function      %
  % MATLAB.CODETOOLS.REQUIREDFILESANDPRODUCTS is called and returns a cell     %
  % array CalledFunctions which contains the dependencies of the function      %
  % UserFunName.  Note that the dependencies found in CalledFunctions include  %
  % UserFunName itself.  Next, because the cell array CalledFunctions is a row %
  % array in R2015b and beyond (while in R2015a and prior CalledFunctions was  %
  % a column vector), CalledFunctions must be transposed to give a cell array  %
  % that is oriented as a column.  Third, prior to R2015b, CalledFunctions was %
  % ordered such that its FIRST entry was the full path to UserFunName. As of  %
  % R2015b and beyond, however, UserFunName is NOT the first entry in the cell %
  % array CalledFunctions.  Because ADIGATOR assumes that CalledFunctions is   %
  % ordered such that CalledFunctions{1} = $full-path/UserFunName, a swap must %
  % be performed to place UserFunName in CalledFunctions{1}.                   %
  %----------------------------------------------------------------------------%
  [CalledFunctions,~] = matlab.codetools.requiredFilesAndProducts(UserFunName);
  CalledFunctions = CalledFunctions(:);
  for kk = 1:length(CalledFunctions)
    indexOfString = strfind(CalledFunctions{kk},[filesep,UserFunName,'.m']);
    if ~isempty(indexOfString),
      thisIsIt = kk;
      break
    end
  end
  CFswap = CalledFunctions{thisIsIt};
  CalledFunctions{thisIsIt} = CalledFunctions{1};
  CalledFunctions{1} = CFswap;
  
  % The new format is already recursive - just check through and remove any
  % adigatorEvalInterp2pp/adigatorGenInterp2pp files
  for CFcount = 2:length(CalledFunctions)
    fileloc = strfind(CalledFunctions{CFcount},filesep);
    if isempty(fileloc); fileloc=0; end;
    filename = CalledFunctions{CFcount}(fileloc(end)+1:end-2);
    if any(strcmp(filename,cadaMethods))
      CalledFunctions{CFcount} = [];
    end
  end
  
  CalledFunctions = CalledFunctions(~cellfun('isempty',CalledFunctions));
end
%--------------------------------------------------------------------------%
% END: Code Added by Anil V. Rao.  15 October 2015.                        %
%--------------------------------------------------------------------------%


% [CalledFunctions,~] = matlab.codetools.requiredFilesAndProducts(UserFunName,'toponly');
return
end

%% ~~~~~~~~~~~~~~~~~~~~~~ PARSE FUNCTION INPUT/OUTPUT ~~~~~~~~~~~~~~~~~~ %%
function [OutNames,InNames,Fstr, FileLoc,MajorLineCount] = parsefuncIO(fid,MajorLineCount,FileLoc)
% ---------------Parse Function Input String------------------------------%
fseek(fid,FileLoc,-1);

Fstr = fgets(fid); 
if isnumeric(Fstr)
  OutNames = []; InNames = []; Fstr = []; FileLoc = []; MajorLineCount = [];
  return
end
Fstr = strtrim(Fstr);
while length(Fstr) < 8 || strcmp(Fstr(1:8),'function') == 0 % -- get to function line --
  FileLoc = ftell(fid);
  Fstr = fgets(fid); 
  if isnumeric(Fstr)
    OutNames = []; InNames = []; Fstr = []; FileLoc = []; MajorLineCount = [];
    return
  end
  Fstr = strtrim(Fstr);
  MajorLineCount = MajorLineCount+1;
end
while strcmp(Fstr(end-2:end),'...');
  Fstr = [Fstr(1:end-3),strtrim(fgets(fid))];
end

% -- find outputs --
outloc1 = strfind(Fstr,'[');
outloc2 = strfind(Fstr,']'); 
if isempty(outloc1)
  outloc2 = strfind(Fstr,'=');
  if isempty(outloc2)
    NumOutVars = 0;
  else
    OutNames = cell(1,1);
    OutNames{1} = strtrim(Fstr(9:outloc2-1));
    NumOutVars  = 1;
  end
else
  outstr     = strtrim(Fstr(outloc1+1:outloc2-1));
  SpaceLocs  = isspace(outstr);
  CommaLocs  = strfind(outstr,',');
  SpaceLocs(CommaLocs) = true;
  SpaceLocs1 = 1:length(outstr);
  SpaceLocs  = SpaceLocs1(SpaceLocs);

  if isempty(SpaceLocs)
    OutNames = cell(1);
    OutNames{1} = outstr;
    NumOutVars = 1;
  else
    % First
    VarLocs = zeros(length(SpaceLocs)+1,2);
    VarLocs(1,1) = 1; VarLocs(1,2) = SpaceLocs(1)-1;
    NumOutVars = 1;
    
    % Middle
    for Scount = 1:length(SpaceLocs)-1
      % Looking for the start of a variable.
      if SpaceLocs(Scount)+1 ~= SpaceLocs(Scount+1)
        NumOutVars = NumOutVars+1;
        VarLocs(NumOutVars,1) = SpaceLocs(Scount)+1;
        VarLocs(NumOutVars,2) = SpaceLocs(Scount+1)-1;
      end
    end
    
    % Last
    NumOutVars = NumOutVars+1;
    VarLocs(NumOutVars,1) = SpaceLocs(end)+1;
    VarLocs(NumOutVars,2) = length(outstr);

    OutNames = cell(NumOutVars,1);
    for Vcount = 1:NumOutVars
      OutNames{Vcount} = outstr(VarLocs(Vcount,1):VarLocs(Vcount,2));
    end
  end
end
% -- find inputs --
inloc1  = strfind(Fstr,'('); inloc1 = inloc1(1);
inloc2  = strfind(Fstr,')'); inloc2 = inloc2(1);
if isempty(inloc1) || isempty(inloc2)
  NumIn = 0;
else
  instr   = strtrim(Fstr(inloc1+1:inloc2-1));
  inlocs  = strfind(instr,',');
  NumIn   = length(inlocs)+1;
  inlocs  = [0,inlocs,length(instr)+1];
  InNames = cell(NumIn,1);
  for Vcount = 1:NumIn
    InNames{Vcount} = strtrim(instr(inlocs(Vcount)+1:inlocs(Vcount+1)-1));
  end
end
if (~NumOutVars || ~ NumIn) 
  if ~isempty(strfind(Fstr,'ADiGator_LoadData'))
    InNames = [];  NumIn = 0;
    OutNames = []; NumOutVars = 0;
  else
    error('All user functions and sub-functions must have at least one input and one output.')
  end
end
for Icount = 1:NumIn
  if strcmp(InNames{Icount},'varargin')
    error('adigator cannot differentiate functions with varargin inputs')
  end
end
for Ocount = 1:NumOutVars
  if strcmp(OutNames{Ocount},'varargout')
    error('adigator cannot differentiate functions with varargout outputs')
  end
end
return
end

%% ~~~~~~~~~~~~~~~~~~~~~~~ READ FILE FOR FLOW CONTROL ~~~~~~~~~~~~~~~~~~ %%
function [MajorLineCount,MinorLineCount,FlowInfo,FileLoc,OuterCount,DataCount,OffSet] =...
  flowread(fid,MajorLineCount,MinorLineCountIn,FlowInfo,FileLoc,OuterCount,DataCount)
% function [MajorLineCount,MinorLineCount,FlowInfo,FileLoc] = flowread(fid,MajorLineCount,MinorLineCountIn,FlowInfo,FileLoc)
% Recursively calls itself to find control flow of the function file
% ----------------------------------------------------------------------- %
% NOTES:
%       FlowInfo is 1 x No structure array with the following fields:
%               .Type          : String with 'if','elseif','for', etc.
%               .StartLocation : [MajorLineCount, MinorLineCount, DataCount, FileLoc]
%               .Children      : Recursively embed FlowInfo
%               .EndLocation   : [MajorLineCount, MinorLineCount, DataCount, FileLoc]
fseek(fid,FileLoc,-1);
FileLoc        = ftell(fid);
cadaFunStrFULL = fgets(fid);
MajorLineCount = MajorLineCount + 1;
OffSet         = 1;
FirstFlag      = 1;
while ~isnumeric(cadaFunStrFULL)
  cadaFunStrFull = strtrim(cadaFunStrFULL);
  if ~isempty(cadaFunStrFull) && ~strcmp(cadaFunStrFull(1),'%')
    if length(cadaFunStrFull) > 3
      while strcmp(cadaFunStrFull(end-2:end),'...');
        cadaFunStrFull = [cadaFunStrFull(1:end-3),strtrim(fgets(fid))];
        MajorLineCount = MajorLineCount + 1;
        OffSet         = OffSet+1;
      end
      squarelocs1 = strfind(cadaFunStrFull,'[');
      squarelocs2 = strfind(cadaFunStrFull,']');
      while length(squarelocs1) > length(squarelocs2)
        commentLoc = strfind(cadaFunStrFull,'%');
        if ~isempty(commentLoc)
          cadaFunStrFull = strtrim(cadaFunStrFull(1:commentLoc(1)));
        end
        if strcmp(cadaFunStrFull(end),';')
          cadaFunStrFull = [cadaFunStrFull,strtrim(fgets(fid))]; %#ok<AGROW>
        else
          cadaFunStrFull = [cadaFunStrFull,';',strtrim(fgets(fid))]; %#ok<AGROW>
        end
        MajorLineCount = MajorLineCount + 1;
        OffSet         = OffSet+1;
        while strcmp(cadaFunStrFull(end-2:end),'...');
          cadaFunStrFull = [cadaFunStrFull(1:end-3),strtrim(fgets(fid))];
          MajorLineCount = MajorLineCount + 1;
          OffSet         = OffSet+1;
        end
        squarelocs1 = strfind(cadaFunStrFull,'[');
        squarelocs2 = strfind(cadaFunStrFull,']');
      end
    end
    [cadaFunStr, cadaNUMFunStr] = adigatorSeperateFunLines(cadaFunStrFull);
    for MinorLineCount = 1:cadaNUMFunStr
      if FirstFlag == 0 || MinorLineCount > MinorLineCountIn
        cadaFunStri   = cadaFunStr{MinorLineCount};
        cadaStrLength = length(cadaFunStri);
        if cadaStrLength > 2 && strcmp(cadaFunStri(1:3),'if ')
          % IF STATEMENT
          OuterCount      = OuterCount + 1;
          StartOuterCount = OuterCount;
          DataCount       = DataCount + 1;
          % Assign Outer Flow Cell
          FlowInfo(OuterCount).Type          = 'if';
          FlowInfo(OuterCount).StartLocation = [MajorLineCount, MinorLineCount,DataCount,FileLoc];
          FlowInfo(OuterCount).Children      = struct('Type',cell(0),'StartLocation',cell(0),...
            'EndLocation',cell(0),'Children',cell(0));
          
          MajorLineCount   = MajorLineCount - OffSet;
          MinorLineCountIn = MinorLineCount;
          InnerCount = 0;
          
          EndFlag = 0;
          while EndFlag == 0 % Run Loop until we find the END statement for outer IF statement
            [MajorLineCount,MinorLineCountIn,TempFlowInfo,FileLoc,InnerCount,DataCount] =...
              flowread(fid,MajorLineCount,MinorLineCountIn,FlowInfo(OuterCount).Children,FileLoc,InnerCount,DataCount);
            if isempty(TempFlowInfo)
              % END
              DataCount = DataCount+1;
              FlowInfo(OuterCount).EndLocation = [MajorLineCount,MinorLineCountIn,DataCount,FileLoc];
              %DataCount = DataCount+1; % This DataCount is for the UNION
              EndFlag = 1;
            elseif isstruct(TempFlowInfo)
              % CHILDREN
              FlowInfo(OuterCount).Children = TempFlowInfo(1:InnerCount);
              MajorLineCount                = MajorLineCount - OffSet;
            elseif ischar(TempFlowInfo)
              % ELSEIF | ELSE
              InnerCount  = 0;
              DataCount   = DataCount + 1;
              FlowInfo(OuterCount).EndLocation = [MajorLineCount,MinorLineCountIn,DataCount,FileLoc];
              OuterCount = OuterCount + 1;
              FlowInfo(OuterCount).Type          = TempFlowInfo;
              FlowInfo(OuterCount).StartLocation = [MajorLineCount,MinorLineCountIn,FlowInfo(StartOuterCount).StartLocation(3),FileLoc];
              FlowInfo(OuterCount).Children      = struct('Type',cell(0),'StartLocation',cell(0),...
                'EndLocation',cell(0),'Children',cell(0));
              MajorLineCount                     = MajorLineCount - OffSet;
            end
          end
          % END statement found
          MinorLineCount = MinorLineCountIn; %#ok<FXSET>
          return
        elseif cadaStrLength > 7 && strcmp(cadaFunStri(1:7),'elseif ')
          % ELSEIF STATEMENT
          FlowInfo = 'elseif';
          return
        elseif cadaStrLength > 3 && strcmp(cadaFunStri(1:4),'else')
          % ELSE STATEMENT
          FlowInfo = 'else';
          return
        elseif (cadaStrLength > 3 && strcmp(cadaFunStri(1:4),'for ')) || ...
            (cadaStrLength > 5 && strcmp(cadaFunStri(1:6),'while '))
          % FOR/WHILE STATEMENT
          OuterCount = OuterCount+1;
          DataCount  = DataCount+1;
          % Assign Outer Flow Cell
          FlowInfo(OuterCount).Type           = 'for';
          FlowInfo(OuterCount).StartLocation  = [MajorLineCount, MinorLineCount,DataCount,FileLoc];
          FlowInfo(OuterCount).Children       = struct('Type',cell(0),'StartLocation',cell(0),...
                'EndLocation',cell(0),'Children',cell(0));
              
          MajorLineCount   = MajorLineCount - OffSet;
          MinorLineCountIn = MinorLineCount;
          InnerCount       = 0;
          EndFlag          = 0;
          
          while EndFlag == 0 % Run Loop until we find the END statement for outer IF statement
            [MajorLineCount,MinorLineCountIn,TempFlowInfo,FileLoc,InnerCount,DataCount] =...
              flowread(fid,MajorLineCount,MinorLineCountIn,FlowInfo(OuterCount).Children,FileLoc,InnerCount,DataCount);
            if isempty(TempFlowInfo)
              % END
              DataCount = DataCount+1;
              FlowInfo(OuterCount).EndLocation = [MajorLineCount,MinorLineCountIn,DataCount,FileLoc];
              %DataCount = DataCount+1; % This DataCount is for the UNION
              EndFlag = 1;
            else
              % CHILDREN
              FlowInfo(OuterCount).Children = TempFlowInfo(1:InnerCount);
              MajorLineCount                = MajorLineCount - OffSet;
            end
          end
          % END statement found
          MinorLineCount = MinorLineCountIn; %#ok<FXSET>
          return 
        elseif cadaStrLength > 2 && strcmp(cadaFunStri(1:3),'end')
          % END STATEMENT
          FlowInfo = [];
          return
        end
      end
    end
  end
  FirstFlag      = 0;
  FileLoc        = ftell(fid);
  cadaFunStrFULL = fgets(fid);
  MajorLineCount = MajorLineCount + 1;
  OffSet         = 1;
end
FlowInfo = [];
return
end

%% ~~~~~~~~~~~~~~ BUILD OVERMAPPED INPUTS TO TEMP FUNCTIONS ~~~~~~~~~~~~ %%
function cadaOverVars = cadaGetOverVars(FunID,FunctionInfo,cadaOverStrucVars) 
% Gets OverMapped variables for Printing Evaluation call to
% subfunctions/called functions
  cadaOverVars = cell(size(FunctionInfo(FunID).Input.Names));
  for cadaOcount = 1:length(cadaOverStrucVars)
    eval([FunctionInfo(FunID).Input.StrucNames{cadaOcount},...
      ' = cadaOverStrucVars{cadaOcount};']);
  end
  for cadaOcount = 1:length(cadaOverVars)
    cadaOverVars{cadaOcount} = eval(FunctionInfo(FunID).Input.Names{cadaOcount});
  end
end

%% ~~~~~~~~ DETERMINE IF ANY DERIVATIVES HAVE ALREADY BEEN PRINTED ~~~~~ %%
function [DerivCheckCell, LastDerivNum,DerNumber] = getderivchecks(PreviousDerivData)
global ADIGATOR
NUMvod = ADIGATOR.NVAROFDIFF;
if ~isempty(PreviousDerivData)
  NumPrevDerivs = length(PreviousDerivData.Derivative);
  
  DerInNames = cell(NUMvod,1);
  for Vcount = 1:NUMvod
    DerInNames{Vcount} = ADIGATOR.VAROFDIFF(Vcount).name;
  end
  DerInNamesold = DerInNames;
  DerivCheckMatrix = false(NumPrevDerivs,NUMvod);
  % DerivCheckMatrix is m x n
  %     rows - number of source transformations performed on this file plus
  %     the one that is about to be performed
  %     cols - the variables with which derivatives have been taken wrt
  %     if element i,j is true, then the derivative of variable j was taken
  %     on source transformation run i
  for Dcount = 1:NumPrevDerivs
    PrevVars = PreviousDerivData.Derivative(Dcount).Variables;
    for Vcount = 1:length(PrevVars);
      NameCheck = strcmp(PrevVars(Vcount).name,DerInNamesold);
      if any(NameCheck)
        DerivCheckMatrix(Dcount,NameCheck) = true;
      else
        DerInNames{end+1} = PrevVars(Vcount).name; %#ok<AGROW>
        DerivCheckMatrix(Dcount,end+1) = true; %#ok<AGROW>
      end
    end
  end

  % Need to find the last source transformation iteration which derivatives
  % were not taken wrt.
  LastDerivNum = 0;
  for Icount = 1:size(DerivCheckMatrix,1)
    if DerivCheckMatrix(Icount,:)
      LastDerivNum = Icount;
    end
  end
  for Vcount = 1:length(DerInNames)
    DerInNames{Vcount} = ['d',DerInNames{Vcount}];
  end
  % ----Get the Deriv Checks---- %
  % DerivCheckNum - if > 0, will check for cada#tf & cada#td, and calculate
  % derivatives of these (corresponding the the temporary variables needed
  % to calculate the last derivative we need)
  % DerivCheckCell - cell of strings which contain the endings that we need
  % to print derivatives for.
  % This is all done so that we don't print out redundant derivative
  % calculations. Ex. calculating second derivative wrt x, we y.dx is
  % already printed, so we dont need to print out the derivative of y.f
  % (y.dx), but we do need to print out derivatives of y.dx (y.dxdx) and
  % cada1tf, cada1td, since these are the temporary variables used in
  % getting to y.dx
  if LastDerivNum
    DerivCheckMatrix2 = DerivCheckMatrix(1:LastDerivNum,:);
    DerivCheckCell    = cell(nnz(DerivCheckMatrix2).^2*3*(LastDerivNum-1),1); 
    DCcount = 1;
    DerivCheckCell{DCcount} = sprintf('\\<cada%1.0ftf',LastDerivNum);
    DCcount = DCcount+1;
    DerivCheckCell{DCcount} = sprintf('\\<cada%1.0ftd',LastDerivNum);

    
    EndStrings = FindDerivChecks(DerivCheckMatrix2,DerInNames);
    for Ecount = 1:length(EndStrings)
      DCcount = DCcount+1;
      DerivCheckCell{DCcount} = ['(\w*)+',EndStrings{Ecount},'\>'];
    end
    
    for Dcount = 1:LastDerivNum-1
      ChildCells = FindDerivChecks(DerivCheckMatrix2(1:LastDerivNum-Dcount,:),DerInNames);
      for Ccount = 1:length(ChildCells)
        DCcount = DCcount+1;
        DerivCheckCell{DCcount} = sprintf(['\\<cada%1.0ff(\\w*)+',ChildCells{Ccount},'\\>'],Dcount+1);
        DCcount = DCcount+1;
        DerivCheckCell{DCcount} = sprintf(['\\<cada%1.0ftemp(\\w*)+',ChildCells{Ccount},'\\>'],Dcount+1);
        DCcount = DCcount+1;
        DerivCheckCell{DCcount} = sprintf(['\\<cada%1.0ftf(\\w*)+',ChildCells{Ccount},'\\>'],Dcount);
        DCcount  = DCcount+1;
        DerivCheckCell{DCcount} = sprintf(['\\<cada%1.0ftd(\\w*)+',ChildCells{Ccount},'\\>'],Dcount);
      end
    end

    if size(DerivCheckMatrix,1) > LastDerivNum
      for Dcount = LastDerivNum+1:size(DerivCheckMatrix,1)
        DCcount = DCcount+1;
        DerivCheckCell{DCcount} = sprintf('\\<cada%1.0f',Dcount);
      end
    end
    DerivCheckCell = DerivCheckCell(1:DCcount);
  else
    DerivCheckCell = [];
  end
  DerNumber = NumPrevDerivs+1;
else
  DerivCheckCell  = [];
  LastDerivNum    = 0;
  DerNumber       = 1;
end
return
end

function OutCell = FindDerivChecks(InMatrix,InNames)

DSize = size(InMatrix,1);
if DSize == 1
  OutCell = InNames(logical(InMatrix));
else
  ParentCells = InNames(logical(InMatrix(1,:)));
  ChildCells  = FindDerivChecks(InMatrix(2:end,:),InNames);
  OutCell = cell(length(ParentCells)*length(ChildCells),1);
  Ocount = 0;
  for Pcount = 1:length(ParentCells)
    for Ccount = 1:length(ChildCells)
      Ocount = Ocount+1;
      OutCell{Ocount} = [ParentCells{Pcount},ChildCells{Ccount}];
    end
  end
end
end